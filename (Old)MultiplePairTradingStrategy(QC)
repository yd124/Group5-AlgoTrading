# reference:
# sharpe ratio: https://github.com/QuantConnect/Lean/blob/6af20c3d8a5713ef1e58ae924e05cde0a5fff8fd/Common/Statistics/Statistics.cs

from clr import AddReference
AddReference("System")
AddReference("QuantConnect.Algorithm")
AddReference("QuantConnect.Common")

from System import *
from QuantConnect import *
from QuantConnect.Algorithm import *
from QuantConnect.Orders import *
from QuantConnect.Orders.Fees import *
from QuantConnect.Securities import *
from QuantConnect.Orders.Fills import *
from QuantConnect.Brokerages import *
from QuantConnect.Algorithm.Framework.Risk import *
from QuantConnect.Data.Custom.USTreasury import *

from sklearn.linear_model import LinearRegression
import numpy as np
import pandas as pd
import math 
import statsmodels.api as sm
from statsmodels.tsa.stattools import coint, adfuller
from datetime import datetime
import decimal as d


class MultiplePairTrading(QCAlgorithm):
    def Initialize(self):
        
        # In-sample between 1/2/2018 and 4/15/2021
        self.SetStartDate(2018, 1, 2)      
        self.SetEndDate(2021,4,15)
        
        # Stress Testing between 1/4/2016 and 12/29/2017
        #self.SetStartDate(2020, 3, 1)      
        #self.SetEndDate(2020,3,31)
       
        # Out-sample between 1/4/2016 and 12/29/2017
        # self.SetStartDate(2016, 1, 4)      
        # self.SetEndDate(2017,12,29)
        
        self.cash = 1000000  
        self.SetCash(self.cash)
        
        self.enter = []
        self.exit = []
        self.lookback = []
        self.stdlookback = 30
        self.resolution = Resolution.Hour
        
        # self.UniverseSettings.Resolution = Resolution.Hour
        
        # Pairs Selection ----------------------------------------------------------------
        # self.pairs =[['RUSHA', 'RUSH']]
        
        self.pairs = [['ESNT', 'MTG'], ['BMTC', 'ABTX'], ['TOWN', 'GVBK'],\
        ['OTCM', 'RVT'], ['THFF', 'GSBC'],['FMBH', 'AROW'], ['TMP', 'CATY'],\
        ['TOL', 'TPH'], ['CROX', 'CNGR'],['CCS', 'TMHC'], ['GCO', 'GIII'],\
        ['TDS', 'USM'], ['AMOV', 'AMX'],['NUVA', 'SPNEV'], ['TMO', 'DHR'],\
        ['CNI', 'NSC'], ['LFUS', 'AVT']] 
 
        
        # Add Equities ----------------------------------------------------------------
        self.num = len(self.pairs)  
        self.symbols = []
        self.securities = []
        
        for pair in self.pairs:
            symbol = []
            security = []
            for ticker in pair:
                equity = self.AddEquity(ticker, Resolution.Hour)
                symbol.append(self.Symbol(ticker))
                security.append(equity.Symbol)
            self.symbols.append(symbol)
            self.securities.append(security)
       
        # Fund Allocation ------------------------------------------------------
        self.buying_power = []
        weight = []
        # Method 1: Equal Allocation:
        for i in range(self.num):
            weight.append(1/self.num)
        
        # Method 2 & 3:
        # one_year_volatility_inverse = []
        # for i in range(self.num):
        #     one_year_volatility_inverse.append(1/self.one_year_volatility_calc(self.symbols[i][0], self.symbols[i][1]))
        '''
        # Method 2: reduce allocation when volatility > 1
        for i in range(self.num):
            weight.append(1/ self.num * min(1,one_year_volatility_inverse[i]))
        '''
        '''
        # Method 3: normalized weight by volatility
        sum = np.sum(one_year_volatility_inverse)
        for i in range(self.num):
            weight.append(one_year_volatility_inverse[i]/sum)
        '''
        '''
        # Method 4: Allocate more weight on better performance pair
        # Run Method 1 & 2 & 3 in-sample, then determine the weight percentage
        
        '''
        for i in range(self.num):
           self.buying_power.append([ 2*self.cash * weight[i] ])
        
        # ----------------------------------------------------------------
        self.ticker_holdings = []   # self.Portfolio[self.pairs[i][0]]
        self.init_value = []    # market value for each stock in one pair when they enter into the market
        self.init_pos = []  # position while entering to the market
        self.liq_fee = [] # liquidation fee per pair
        self.profit_loss_after_market_order_fee = [] # profit and loss (after deduction of market order fee) before liquidation during each trading period per pair
        self.profit_loss_before_liq_fee = [] # profit and loss (before deduction of market order fee) = PnL of stock1 + PnL of stock2 (excludes market order fee)
        self.total_profit_loss = [] # total profit and loss of i-th pair during the sample period
        self.profit_loss_percentage = []    # total profit and loss/ initial cash
        # self.pair_daily_pnl = []    # daily profit and loss for i-th pair
        # self.pair_daily_profit = []  # daily profit for i-th pair
        # self.pair_daily_loss = []    # daily loss for i-th pair
        
        for i in range(self.num):
            self.ticker_holdings.append(self.Portfolio[self.pairs[i][0]])
            self.init_value.append([0, 0])
            self.init_pos.append([0,0])
            self.liq_fee.append(0)
            self.profit_loss_after_market_order_fee.append(0)
            self.profit_loss_before_liq_fee.append(0)
            self.total_profit_loss.append([0])
            self.profit_loss_percentage.append([0])
            self.enter.append(1)
            self.exit.append(0)

            self.lookback.append(30)
            
        # Cash Buffer ------------------------------------------------------------
        # Adjust the cash buffer from the default 2.5% to 5%
        self.Settings.FreePortfolioValuePercentage = 45
        self.buffer = 0.35
        # self.buffer = 0.45
        
        # Entry Condition ----------------------------------------------------------
        # beta should be inside [0.75, 1.25] since beta -> 1 is much more profitable
        # self.betarange = 0.25  [1-betarange, 1+betarange]
        self.betarange = 0.75  #[betarange, 1/betarange]
        
        # Brokerage ------------------------------------------------------------
        self.SetBrokerageModel(BrokerageName.InteractiveBrokersBrokerage, AccountType.Margin)
        
        # Risk Management ------------------------------------------------------
        # stop-loss
        self.stop = [4, 4] 
        # maximum drawdown
        self.vt = []
        self.maximum_drawdown_percentage = 0.2
        # daily-pnl-volatility
        self.port_daily_pnl = []
        # sharpe ratio
        self.rate_of_return = []    
        self.daily_performance = []
        # valu-at-risk
        self.var_limit = [5000, 10000, 20000,10000]
        self.ci = 0.95
        
        
        # Execution ------------------------------------------------------------
        self.SetExecution(ImmediateExecutionModel())       
        
        # Risk Free Rate ------------------------------------------------------------
        self.yield_curve = self.AddData(USTreasuryYieldCurveRate, "USTYCR").Symbol
        self.rates = []
        
        # Warm Up --------------------------------------------------------------        
        self.SetWarmUp(timedelta(max(self.lookback)))
    
        #  ------------------------------------------------------------
        self.yesterday_total_profit = 0
        self.yesterday_total_fees = 0
        self.yesterday_total_unrealized_profit = 0       
        self.yesterday_total_portfolio_value = self.cash
 
            
        #Add-on fine tuning -----------------------------------------------
        self.adjustthreshold = False
        self.voladjust = False
        self.vixadjust = False
        self.exit_change = 0
        self.weightmethod = 'cointegration'
        self.calmperiod = False
        #self.calmperiodlength = timedelta(1)
        self.abnormalbetasell = False
        self.altZscore = False
        self.adjustAltzscore = False
        self.Zscorediff = 3
        self.altZscorestop = 5
        #self.maxpercentageloss = -0.1
        #self.maxlosslimit = True
        self.volcapitalalloc = False
        self.changelookback = True
        self.stdvol = 49
        self.enhancedvol = False


        #lookback period---------------------------------------
        if self.changelookback:
            vol = [0] * self.num
            for i in range(self.num):
                histone = np.log(self.History(self.symbols[i][0], 210, self.resolution).close.values)
                histtwo = np.log(self.History(self.symbols[i][1], 210, self.resolution).close.values)
                vol1 = np.std(histone) / np.mean(histone)
                vol2 = np.std(histtwo) / np.mean(histtwo)
                vol[i] = math.log10((vol1 + vol2)/2)
            #vol_norm = [(vol[i] - sum(vol) / len(vol)) / statistics.pstdev(vol) for i in range(self.num)]
            for i in range(self.num):
                self.lookback[i] = self.stdvol - 7 * round((vol[i] - sum(vol) / len(vol))*2)
                if abs(vol[i] - sum(vol) / len(vol)) > 1.2:
                    self.Log(str(self.pairs[i]) + " has weird volatility!")
                if self.lookback[i] < 14:
                    self.Log(str(self.pairs[i]) + " has too much volatility!")
                    self.lookback[i]  = 14
                self.Log(str(self.pairs[i]) + "  " + str(self.lookback[i]))
    
    def OnEndOfAlgorithm(self):
        self.Log("checking the performance of the pairs: ")
        for i in range(self.num):
            # self.Log(f"{i}th total profit loss: {self.total_profit_loss[i][-1]}")
            self.Log(f"{i+1}th total profit percentage: {self.profit_loss_percentage[i][-1]}")
    
    def OnData(self,data):
        if self.IsWarmingUp: return

    
        if (self.Time.hour >= 10) and (self.Time.hour < 15):
            for i in range(self.num):
                for j in range(2):
                    if not data.ContainsKey(self.pairs[i][j]): return
            
            for i in range(self.num):
                # self.Log(f"check {i}")
                [zscore, beta, adf] = self.port_check(self.symbols[i][0], self.symbols[i][1], data[self.symbols[i][0]].Price, data[self.symbols[i][1]].Price, i)
                if zscore == None: 
                    self.Log("different length!")
                    continue
                wt1 = beta/(1 + beta)
                wt2 = 1/(1 + beta)
                
                [actual_enter, actual_exit] = self.AdjustedThreshold(self.enter[i], self.exit[i], i)
                
                self.equity = self.Portfolio.TotalPortfolioValue
        
                if self.ticker_holdings[i].Invested:
                    if (self.ticker_holdings[i].IsShort and zscore >= -actual_exit) or \
                        (self.ticker_holdings[i].IsLong and zscore <= actual_exit):
                            self.liq_fee[i] = self.liq_fee_calc(i, data[self.symbols[i][0]].Price, data[self.symbols[i][1]].Price)
                            self.total_profit_loss[i].append( self.total_profit_loss[i][-1] + self.profit_loss_after_market_order_fee[i] - self.liq_fee[i])
                            self.profit_loss_percentage[i].append(round(self.total_profit_loss[i][-1]/(self.buying_power[i][0]/2) * 100, 3))
                            
                            self.Liquidate(self.pairs[i][0])
                            self.Liquidate(self.pairs[i][1])
                            
                                
                    # Risk Management: Stop-Loss -----------------------------------      
                    # self.risk_management_stop_loss(i, zscore)
                    
                    # Risk Management: Value-at-Risk -------------------------------
                    # Adjust weight
                    # self.risk_management_value_at_risk(i, wt1, wt2, data[self.symbols[i][0]].Price, data[self.symbols[i][1]].Price)

                    # Risk Management: Maximum Drawdown -----------------------------------
                    # self.risk_management_maximum_drawdown(self.maximum_drawdown_percentage)
                    
                    # Risk Management: Daily PnL Volatility ------------------------
                    # daily pnl volatility < 5% of equity  
                    # self.risk_management_daily_pnl_volatility(0.05)
                    
                           
                elif beta >= self.betarange and beta <= 1 / self.betarange:
                    price1 = data[self.symbols[i][0]].Price
                    price2 = data[self.symbols[i][1]].Price
                    # self.Log(f"stock1 {price1} and stock2 {price2}")
                    
                    #self.Log("C: " + str(self.buying_power[i][-1] * (1-self.buffer)))
                    #self.Log("C': " + str(self.Portfolio.MarginRemaining + self.Portfolio.Cash))
                    # self.Log(str(beta)+"  "+str(price1)+ '  '+ str(price2))
                    
                    # Sell ticker2 Buy ticker1
                    if zscore > actual_enter:
                        self.buying_power[i].append(self.buying_power[i][-1] + (self.profit_loss_after_market_order_fee[i] - self.liq_fee[i])*2)
                        [pos1, pos2] = self.pos_calc(i, 0, wt1, wt2, price1, price2, self.buying_power[i][-1] * (1-self.buffer))
                        # self.Log(str(pos1)+"  "+str(pos2))                    
                        self.MarketOrder(self.symbols[i][1], pos2, True)
                        self.MarketOrder(self.symbols[i][0], pos1, True)
    
                        
                    # Sell ticker1, Buy ticker2
                    if zscore < - actual_enter:
                        self.buying_power[i].append(self.buying_power[i][-1] + (self.profit_loss_after_market_order_fee[i] - self.liq_fee[i])*2)
                        [pos1, pos2] = self.pos_calc(i, 1, wt1, wt2, price1, price2, self.buying_power[i][-1] * (1-self.buffer))
                        # self.Log(str(pos1)+"  "+str(pos2))  
                        self.MarketOrder(self.symbols[i][0], pos1, True)
                        self.MarketOrder(self.symbols[i][1], pos2, True)
                    
                else:
                    pass
    
    # Calculate liquidate fee 
    def liq_fee_calc(self, i, price1, price2):
        self.profit_loss_after_market_order_fee[i] = self.Portfolio[self.pairs[i][0]].UnrealizedProfit + self.Portfolio[self.pairs[i][1]].UnrealizedProfit
        symbol1_value = price1 * self.init_pos[i][0]  
        symbol2_value = price2* self.init_pos[i][1]  
        
        # market order fee = liquidation fee 
        profit_loss_before_liq_fee = (symbol1_value - self.init_value[i][0]) + (symbol2_value- self.init_value[i][1])
        fee = profit_loss_before_liq_fee - self.profit_loss_after_market_order_fee[i]
        # self.Log(f"liq {fee}")
        return fee
        
    # Calculate market order position
    def pos_calc(self, i, signal, wt1, wt2, price1, price2, C):
        self.init_pos[i][0] = Math.Pow(-1, signal) * round(wt1 * C / price1)
        self.init_pos[i][1] = Math.Pow(-1, signal + 1) * round(wt2 * C / price2)
        self.init_value[i][0] = price1 * self.init_pos[i][0] 
        self.init_value[i][1] = price2 * self.init_pos[i][1] 
        return [self.init_pos[i][0], self.init_pos[i][1]]
        
            
    def OnOrderEvent(self, orderEvent):
        order = self.Transactions.GetOrderById(orderEvent.OrderId)
        if orderEvent.Status == OrderStatus.Filled: 
            # self.Log("{0}: {1}: {2}".format(self.Time, order.Type, orderEvent))
            # self.Log(f"filled {self.Portfolio.TotalPortfolioValue}")
            pass
            
    def OnEndOfDay(self, symbol):
        self.daily_performance.append((self.Portfolio.TotalPortfolioValue - self.yesterday_total_portfolio_value)/self.yesterday_total_portfolio_value  )
        self.port_daily_pnl.append(self.get_port_daily_pnl())
        self.yesterday_total_profit = self.Portfolio.TotalProfit
        self.yesterday_total_fees = self.Portfolio.TotalFees
        self.yesterday_total_unrealized_profit = self.Portfolio.TotalUnrealizedProfit
        self.yesterday_total_portfolio_value = self.Portfolio.TotalPortfolioValue
        

    def get_port_daily_realized_pnl(self):
        daily_gross_profit = self.Portfolio.TotalProfit - self.yesterday_total_profit
        daily_fees = self.Portfolio.TotalFees - self.yesterday_total_fees
        return daily_gross_profit - daily_fees
    
    def get_port_daily_unrealized_pnl(self):
        return self.Portfolio.TotalUnrealizedProfit - self.yesterday_total_unrealized_profit
    
    def get_port_daily_pnl(self):
        return self.get_port_daily_unrealized_pnl() + self.get_port_daily_realized_pnl()
    
    # Risk Management ----------------------------------------------------------
    ## Stop-Loss ---------------------------------------------------------------

    def risk_management_stop_loss(self, i, zscore):
        if (self.ticker_holdings[i].IsShort and zscore <= -self.stop[i]) or \
            (self.ticker_holdings[i].IsLong and zscore >= self.stop[i]):
                self.Liquidate(self.pairs[i][0])
                self.Liquidate(self.pairs[i][1])        
    
    def risk_management_value_at_risk(self, i, wt1, wt2, price1, price2):
        var = self.var_calc(i)
        if (var < -self.var_limit[i]): 
            ratio = -self.var_limit[i]/var
            [adj_wt1, adj_wt2]  = self.adjust_wt(i, ratio, wt1, wt2) 
            # Stock Value
            B = self.Portfolio.TotalHoldingsValue
            C = abs(self.Portfolio[self.pairs[i][0]].Price * self.Portfolio[self.pairs[i][0]].Quantity)+\
                abs(self.Portfolio[self.pairs[i][1]].Price * self.Portfolio[self.pairs[i][1]].Quantity)
            # self.Log(f"{i}-th holdings {B} and {C} and total equity {self.Portfolio.TotalPortfolioValue}")
            self.adjust_market_value(i,ratio, adj_wt1, adj_wt2,price1, price2, C )
                
    def var_calc(self, i):
        if (self.Portfolio[self.pairs[i][0]].Quantity == 0) and (self.Portfolio[self.pairs[i][1]].Quantity):
            return 0
        else: 
            port_diff = pd.DataFrame(data = self.port_daily_pnl[-self.stdlookback:])
            pnl =port_diff.dropna()
            pnl['pct_rank'] = pnl.rank(pct=True)
            pnl.columns =['daily_pl', 'pct_rank']
            pnl = pnl[pnl.pct_rank< 1-self.ci] # Find the tail distribution
            return pnl.daily_pl.max() # the cuto off point is the VaR 
    
    def adjust_wt(self,i, ratio, wt1, wt2):
        adj_wt1 = wt1 * (1 - ratio)
        adj_wt2 = wt2 * (1 - ratio) 
        return [adj_wt1, adj_wt2]  
    
    def adjust_market_value(self, i, adj, adj_wt1, adj_wt2,price1, price2, C):
        pos1 = round(adj_wt1 * C / price1)
        pos2 = round(adj_wt2 * C / price2)
        
        # sell stock2 buy stock1 
        if self.ticker_holdings[i].IsShort:
            self.MarketOrder(self.symbols[i][1], -pos2, True)
            self.MarketOrder(self.symbols[i][0], pos1, True)
        
        # sell stock1 buy stock2
        if self.ticker_holdings[i].IsLong:
            self.MarketOrder(self.symbols[i][0], -pos1, True)
            self.MarketOrder(self.symbols[i][1], pos2, True)    
            
     ## Maximum Drawdown ---------------------------------------------------------------
    def risk_management_maximum_drawdown(self, c):
        self.cum_pnl = self.Portfolio.TotalUnrealizedProfit +self.Portfolio.TotalProfit
        self.vt.append(self.cum_pnl)
        self.pl = np.array(self.vt)
        
        maxx = self.pl.max()
        minn = self.pl.min()
        self.maxdrawdown = maxx - minn
        if (self.maxdrawdown > self.cash * c):
            self.Liquidate()
      
    ## Daily PnL Volatility---------------------------------------------------------------
    def risk_management_daily_pnl_volatility(self, c):
        if (self.port_daily_pnl_std() >= c * self.Portfolio.TotalPortfolioValue):
            for i in range(self.num):
                ratio = c * self.Portfolio.TotalPortfolioValue/self.port_daily_pnl_std()
                [adj_wt1, adj_wt2]  = self.adjust_wt(i, ratio, wt1, wt2) 
                # pair[i] holdings value 
                C = abs(self.Portfolio[self.pairs[i][0]].Price * self.Portfolio[self.pairs[i][0]].Quantity)+\
                abs(self.Portfolio[self.pairs[i][1]].Price * self.Portfolio[self.pairs[i][1]].Quantity)
                self.adjust_market_value(i,adj, adj_wt1, adj_wt2,price1, price2, C )
                
            
    def port_daily_pnl_std(self):
        return np.std(self.port_daily_pnl[-self.stdlookback:])    
    

    ##### ----------------------------------------------------------------------

    def regr_calc(self, x, y):
        if len(x) != len(y):
            return [None,None,None,None]
        regr = LinearRegression()
        x_constant = np.column_stack([np.ones(len(x)), x])
        regr.fit(x_constant, y)
        beta = regr.coef_[1]  # weight of ticker1: ticker2 = beta : 1
        alpha = regr.intercept_
        res = y - x*beta - alpha
        mean = np.mean(res)
        std = np.std(res)
        zscore = (res[-1] - mean)/std 
        adf = adfuller(res)        
        return [std, zscore, beta, adf]
        
    def port_check(self, symbol1, symbol2, open1, open2, i):
        hist1 = self.History(symbol1, self.lookback[i], self.resolution).open
        hist2 = self.History(symbol2, self.lookback[i], self.resolution).open
        hist1.index = hist1.index.droplevel(0)
        hist2.index = hist2.index.droplevel(0)
        hist1_r = hist1[(hist1.index.isin(hist2.index))]
        hist2_r = hist2[(hist2.index.isin(hist1.index))]
        x = np.log(np.append(hist1_r.values, open1))
        y = np.log(np.append(hist2_r.values, open2))
        [std, zscore, beta, adf] = self.regr_calc(x, y)
        
        return [zscore, beta, adf]
    
    def one_year_volatility_calc(self, symbol1, symbol2):
        x = np.log(self.History(symbol1, 252, self.resolution).open.values)
        y = np.log(self.History(symbol2, 252,  self.resolution).open.values)
        [std, zscore, beta, adf] =  self.regr_calc(x ,y)
        return std


    #Add-on dynamic functions---------------------------------------------------------------
    def WeightFunction(self, pair):
        if self.weightmethod == 'cointegration':
            beta = self.beta[pair]
        elif self.weightmethod == 'volatility':
            vol1 = np.std(np.diff(self.histone))
            vol2 = np.std(np.diff(self.histtwo))
            beta = vol1 / vol2
        elif self.weightmethod == 'EW':
            beta = 1
        elif self.weightmethod == 'min distance':
            beta = minimize(self.PriceDistance, 1, args = (self.histone, self.histtwo), \
                        constraints = ({'type': 'ineq', 'fun': lambda x: x - 0.5},\
                                        {'type': 'ineq', 'fun': lambda x: 1.5 - x})).x[0]
        elif self.weightmethod == 'correlation return':
            x = np.diff(self.histone)
            y = np.diff(self.histtwo)
            beta = self.Regression(x,y)[1]
        
        else: 
            beta = 0
    
        return beta
        
    def AdjustedThreshold(self, enter, exit, i):
        if self.adjustthreshold is False:
            return [enter, exit]
        
        vol_factor = 1
        actual_vol_factor = 1
        if self.vixadjust:
            vix_hist = self.History([self.vix], 5 , Resolution.Daily)
            vol_factor = 0.9 + vix_hist['close'][-1] / 100
        
        if self.voladjust:
            hist1 = np.log(self.History(symbol1, self.lookback[i], self.resolution).open.values)
            hist2 = np.log(self.History(symbol2, self.lookback[i], self.resolution).open.values)
            vol1 = np.std(histone) / np.mean(histone)
            vol2 = np.std(histtwo) / np.mean(histtwo)
    
            vol = max(vol1, vol2)
            #self.Log(str(pair)+": "+str(vol1)+", "+str(vol2))
            vol_factor = 0.9 - float(self.lookback[pair] -self.stdvol) / 70 + math.sqrt(self.pairvol[pair] * 10 * vol)
            #self.Log(str(pair) + " vol_factor:" + str(vol_factor))
            #self.vol[pair].append(vol_factor)
            
            if len(self.vol[pair]) < 2 * self.stdvol:
                self.vol[pair].append(vol_factor)
                #self.vol[pair].pop(0)
            actual_vol_factor = 3 * vol_factor - 2 * sum(self.vol[pair]) / len(self.vol[pair])
            #actual_vol_factor = 1 + vol_factor - sum(self.vol[pair]) / len(self.vol[pair])
            #actual_vol_factor = vol_factor/ (sum(self.vol[pair]) / len(self.vol[pair]))
            if not self.enhancedvol:
                actual_vol_factor = vol_factor
            
        adjusted_enter = enter * actual_vol_factor
        #[i * vol_factor for i in enter]
        adjusted_exit = self.exit_change + exit * actual_vol_factor
        if self.adjustAltzscore: 
            self.Zscorediff = self.Zscorediff * actual_vol_factor
            self.altZscorestop = self.altZscorestop * actual_vol_factor
        
        return [adjusted_enter, adjusted_exit]
        
